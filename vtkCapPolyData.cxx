/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkCapPolyData.cxx

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
#include "vtkCapPolyData.h"
#include "vtkObjectFactory.h"

vtkStandardNewMacro(vtkCapPolyData);

//----------------------------------------------------------------------------
vtkCapPolyData::vtkCapPolyData()
{
}

//----------------------------------------------------------------------------
vtkCapPolyData::~vtkCapPolyData()
{
}

//----------------------------------------------------------------------------
void vtkCapPolyData::PrintSelf(ostream& os, vtkIndent indent)
{
  this->Superclass::PrintSelf(os, indent);
}

#include <vtkClipPolyData.h>
#include <vtkCutter.h>
#include <vtkContourTriangulator.h>
#include <vtkPlaneCollection.h>
#include <vtkPolygon.h>
#include <vtkReverseSense.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkImplicitBoolean.h>
#include <vtkImplicitFunctionCollection.h>
#include <vtkPlanes.h>

//----------------------------------------------------------------------------
void GetPlanes(vtkImplicitFunction* function, vtkPlaneCollection* planes)
{
  if (!function || !planes)
  {
    return;
  }

  vtkImplicitBoolean* booleanFunction = vtkImplicitBoolean::SafeDownCast(function);
  if (booleanFunction)
  {
    vtkImplicitFunctionCollection* functions = booleanFunction->GetFunction();
    for (int i = 0; i < functions->GetNumberOfItems(); ++i)
    {
      vtkImplicitFunction* function = vtkImplicitFunction::SafeDownCast(functions->GetItemAsObject(i));
      GetPlanes(function, planes);
    }
  }

  vtkPlane* plane = vtkPlane::SafeDownCast(function);
  if (plane)
  {
    planes->AddItem(plane);
  }

  vtkPlanes* planesFunction = vtkPlanes::SafeDownCast(function);
  if (planesFunction)
  {
    for (int i = 0; i < planesFunction->GetNumberOfPlanes(); ++i)
    {
      planes->AddItem(planesFunction->GetPlane(i));
    }
  }
}


//----------------------------------------------------------------------------
void CreateEndCap(vtkPlaneCollection* planes, vtkPolyData* originalPolyData, vtkImplicitFunction* cutFunction, vtkPolyData* outputEndCap)
{
  vtkNew<vtkAppendPolyData> appendFilter;
  for (int i = 0; i < planes->GetNumberOfItems(); ++i)
  {
    vtkPlane* plane = planes->GetItem(i);
    vtkNew<vtkCutter> cutter;
    cutter->SetCutFunction(plane);
    cutter->SetInputData(originalPolyData);

    vtkNew<vtkContourTriangulator> contourTriangulator;
    contourTriangulator->SetInputConnection(cutter->GetOutputPort());
    contourTriangulator->Update();

    // Create a seam along the intersection of each plane with the triangulated contour.
    // This allows the contour to be split correctly later.
    vtkNew<vtkPolyData> endCapPolyData;
    endCapPolyData->ShallowCopy(contourTriangulator->GetOutput());
    for (int j = 0; j < planes->GetNumberOfItems(); ++j)
    {
      if (i == j)
      {
        continue;
      }
      vtkPlane* plane2 = planes->GetItem(j);
      vtkNew<vtkClipPolyData> clipper;
      clipper->SetInputData(endCapPolyData);
      clipper->SetClipFunction(plane2);
      clipper->SetValue(0.0);
      clipper->GenerateClippedOutputOn();
      vtkNew<vtkAppendPolyData> appendCut;
      appendCut->AddInputConnection(clipper->GetOutputPort());
      appendCut->AddInputConnection(clipper->GetClippedOutputPort());
      appendCut->Update();
      endCapPolyData->ShallowCopy(appendCut->GetOutput());
    }

    // Remove all triangles that do not lie at 0.0.
    double epsilon = 1e-4;
    vtkNew<vtkClipPolyData> clipper;
    clipper->SetInputData(endCapPolyData);
    clipper->SetClipFunction(cutFunction);
    clipper->InsideOutOff();
    clipper->SetValue(-epsilon);
    vtkNew<vtkClipPolyData> clipper2;
    clipper2->SetInputConnection(clipper->GetOutputPort());
    clipper2->SetClipFunction(cutFunction);
    clipper2->InsideOutOn();
    clipper2->SetValue(epsilon);
    clipper2->Update();
    endCapPolyData->ShallowCopy(clipper2->GetOutput());

    double planeNormal[3] = { 0.0 };
    plane->GetNormal(planeNormal);

    vtkCellArray* endCapPolys = endCapPolyData->GetPolys();
    if (endCapPolys && endCapPolyData->GetNumberOfPolys() > 0)
    {
      vtkNew<vtkIdList> polyPointIds;
      endCapPolys->GetCell(0, polyPointIds);
      double polyNormal[3] = { 0.0 };

      // The normal of the triangles generated by vtkContourTriangulator are based on the clockwise/counter-clockwise direction of the largest contour.
      // This normal will not always line up with the desired normal as defined by the plane, so if the normal generated by vtkContourTriangulator faces
      // the wrong  direction, then we need to flip the normals of the polys so that it matches the expected normal.
      vtkPolygon::ComputeNormal(endCapPolyData->GetPoints(), polyPointIds->GetNumberOfIds(), polyPointIds->GetPointer(0), polyNormal);
      if (vtkMath::Dot(polyNormal, planeNormal) < 0.0)
      {
        vtkNew<vtkReverseSense> reverseSense;
        reverseSense->SetInputData(endCapPolyData);
        reverseSense->ReverseCellsOn();
        reverseSense->Update();
        endCapPolyData->ShallowCopy(reverseSense->GetOutput());
      }
    }

    vtkNew<vtkFloatArray> normals;
    normals->SetName("Normals");
    normals->SetNumberOfComponents(3);
    normals->SetNumberOfTuples(endCapPolyData->GetNumberOfPoints());
    for (int i = 0; i < endCapPolyData->GetNumberOfPoints(); ++i)
    {
      normals->SetTuple3(i, planeNormal[0], planeNormal[1], planeNormal[2]);
    }
    endCapPolyData->GetPointData()->SetNormals(normals);
    appendFilter->AddInputData(endCapPolyData);
  }
  appendFilter->Update();
  outputEndCap->ShallowCopy(appendFilter->GetOutput());
}

#include <vtkInformationVector.h>
#include <vtkInformation.h>

//------------------------------------------------------------------------------
//
// Clip through data generating surface.
//
int vtkCapPolyData::RequestData(vtkInformation* vtkNotUsed(request),
  vtkInformationVector** inputVector, vtkInformationVector* outputVector)
{
  // get the info objects
  vtkInformation* inInfo = inputVector[0]->GetInformationObject(0);
  vtkInformation* outInfo = outputVector->GetInformationObject(0);

  // get the input and output
  vtkPolyData* input = vtkPolyData::SafeDownCast(inInfo->Get(vtkDataObject::DATA_OBJECT()));
  vtkPolyData* output = vtkPolyData::SafeDownCast(outInfo->Get(vtkDataObject::DATA_OBJECT()));

  vtkDebugMacro(<< "Clipping polygonal data");

  vtkIdType numPts = input->GetNumberOfPoints();
  vtkPoints* inPts = input->GetPoints();
  if (numPts < 1 || inPts == nullptr)
  {
    vtkDebugMacro(<< "No data to clip");
    return 1;
  }
  if (!this->ClipFunction)
  {
    return 1;
  }

  vtkNew<vtkPlaneCollection> planes;
  GetPlanes(this->ClipFunction, planes);

  CreateEndCap(planes, input, this->ClipFunction, output);

  return 1;
}

//------------------------------------------------------------------------------
// Overload standard modified time function. If Clip functions is modified,
// then this object is modified as well.
vtkMTimeType vtkCapPolyData::GetMTime()
{
  vtkMTimeType mTime = this->Superclass::GetMTime();
  vtkMTimeType time;

  if (this->ClipFunction != nullptr)
  {
    time = this->ClipFunction->GetMTime();
    mTime = (time > mTime ? time : mTime);
  }
  return mTime;
}
